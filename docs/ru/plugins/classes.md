# Передаваемые классы

## Стоит ознакомится

1. Что такое `*args` и `**kwargs`? -> [Пост на habr](https://habr.com/ru/companies/ruvds/articles/482464/)

## KuiToi 
_`kt = KuiToi("PluginName"")`_

### kt.log
_Константа_\
Вернёт преднастроенный логгер

### kt.name
_Константа_\
Вернёт имя плагина

### kt.dir
_Константа_\
Вернёт папку плагина

### kt.open()
_Параметры как у open()_\
Открывает файл в kt.dir

### kt.register_event(event_name: str, event_func: function)
_`event_name: str` -> Имя ивента, по которому будет вызвана `event_func`._\
_`event_func: function` -> Функция, которая будет вызвана._

В `event_func` можно передавать как обычную функцию, так и async - await не нужно делать заранее.\
Ивенты можно создавать так же свои, со своим именем.\
Зарегистрировать можно не ограниченное кол-во ивентов.

### kt.call_event(event_name: str, *args, **kwargs) -> list:
_`event_name: str` -> Имя ивента, который будет вызван._\
_`*args, **kwargs` -> Аргументы, передаваемые во функции._

### **async** kt.call_async_event(event_name: str, *args, **kwargs) -> list:
_`event_name: str` -> Имя ивента, который будет вызван._\
_`*args, **kwargs` -> Аргументы, передаваемые во функции._\
_Необходимо вызывать с `await`_

###### _Советую ознакомиться с *args, **kwargs_, ссылка есть в начале
Данные во все ивенты приходят по типу: `{"event_name": event_name, "args": args, "kwargs": kwargs}`\
`args: list` -> Представляет из себя массив данных, которые переданы в ивент\
`kwargs: dict` -> Представляет из себя словарь данных, которые переданы в ивент
Данные вернутся от всех удачных волнений в массиве.

### kt.call_lua_event(event_name: str, *args) -> list:
_`event_name: str` -> Имя ивента, который будет вызван._\
_`*args` -> Аргументы, передаваемые во функции._

Добавлено для поддержки обратной совместимости.\
lua функция вызывается с прямой передачей аргументов `lua_func(*args)`

### kt.get_player([pid: int], [nick: str]) -> Player | None:
_`pid: int` -> Player ID - Идентификатор игрока._\
_`nick: str` -> Player Nick - Ник игрока._

Метод возвращает объект игрока по его `pid` или `nick`.\
Если не удалось найти игрока вернётся `None`.

### kt.get_players() -> List[Player] | list:

Метод возвращает массив со всеми игроками.\
Массив будет пустой, если игроков нет.

### kt.players_counter() -> int:

Метод возвращает количество игроков, которые сейчас онлайн.

### kt.is_player_connected([pid: int], [nick: str]) -> bool:
_`pid: int` -> Player ID - Идентификатор игрока._\
_`nick: str` -> Player Nick - Ник игрока._

Метод возвращает объект игрока по его `pid`, `nick`.

## Player (или Client) 
_`pl = kt.get_player()`_\
_`pl = event_data['kwargs']['player']`_

### pl.log -> Logger
_Константа_\
Вернёт преднастроенный логгер

### pl.addr -> str
_Константа_\
Вернёт IP адрес игрока

### pl.pid -> int
### pl.cid -> int
_Константа_\
Вернёт id клиента _(pid: PlayerId = cid: ClientId)_

### pl.key -> str
_Константа_\
Вернёт ключ, переданный при авторизации

### pl.nick -> str
_Переменная_\
Ник, переданные при авторизации от сервера BeamMP, можно изменить, последствия не проверенны

### pl.roles -> str
_Переменная_\
Роль, переданная при авторизации от сервера BeamMP, можно изменить (Если установить не верную роль, могут происходить неожиданности.)

### pl.guest -> bool
_Константа_\
Вернёт является ли игрок гостем, передаётся при авторизации от сервера BeamMP

### pl.identifiers -> dict
_Константа_\
Идентификаторы, передаются при авторизации от сервера BeamMP.

### pl.ready -> bool
_Константа, меняется ядром_\
Вернёт bool значение, если True -> игрок скачал все ресурсы, прогрузился на карте

### pl.cars -> dict
_Константа, меняется ядром_\
Возвращает словарь автомобилей по типу:

```python
{
    1: {
        "packet": car_packet,
        "json": car_json,
        "json_ok": bool(car_json),
        "snowman": snowman,
        "over_spawn": (snowman and allow_snowman) or over_spawn,
        "pos": {
            "pos":[0,0,0],
            "rvel":[0,0,0],
            "rot":[0,0,0],
            "vel":[0,0,0],
            "tim":0,
            "ping":0
        }
    },
    2: ...
}
```
Где `1` - car_id\
Где `pkt` - Необработанный пакет который пришел от клиента (Для очень опытных пользователй) \
Где `json` - Обработанный пакет, хранящийся в виде dict\
Где `json_ok` - Смогло ли ядро обработать пакет\
Где `snowman` - Снеговик ли машина\
Где `over_spawn` - Заспавнена ли машина сверх лимита (Разрешается через плагины)\
Где `pos` - Позиция машины (Передаётся через udp)

### pl.last_position -> dict
_Константа, меняется ядром_
Возвращает последнюю позицию игрока


### **async** pl.kick([reason: str = "Kicked!"]) -> None
_`reason: str` -> Причина кика. Параметр не обязателен, по дефолту: `Kicked!`_
Кикает игрока с сервера

### **async** pl.send_message(message: str, [to_all: bool = True]) -> None
_`message: str` -> Текст сообщения, отправляется без "Server:"_
_`to_all: bool` -> Нужно ли отправить это сообщение всем? Параметр не обязателен, по дефолту: `True`_
Отправляет сообщение игроку или всем сразу

### **async** pl.send_event(event_name: str, event_data: Any, [to_all: bool = True]) -> None
_`event_name: str` -> Имя ивента, который будет вызван_
_`event_data: Any` -> Отправляемые данные в ивент._
_`to_all: bool` -> Нужно ли отправить это сообщение всем? Параметр не обязателен, по дефолту: `True`_
Отправляет ивент на клиент.\
Если event_data будет tuple, list, dict, то перед отправкой ядро конвертирует в json через json.dumps(event_data)
Иначе данные будут строкой, без регуляции;

### **async** pl.delete_car(self, car_id: int) -> None
_`car_id: int` -> Идентификатор машины_
Удалят машину у игрока
